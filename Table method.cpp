// Пины светодиодов и кнопок
const int R=13,Y=12,G=11,BTN=2,EMERG=3;

// Состояния светофора
enum St{GREEN,YELLOW,RED,RED_BLINK,WARNING,NIGHT};
St st; // текущее состояние

// Переменные для таймеров и состояний
unsigned long t0,dur,lastBtn=0;
bool ped=0,night=0,btn=0,prevEmerg=0;
int blinkCnt=0;

//Функция управления светодиодами
void leds(int r,int y,int g){
  digitalWrite(R,r);  // Установить состояние красного светодиода (1 - вкл, 0 - выкл)
  digitalWrite(Y,y);  // Установить состояние желтого светодиода (1 - вкл, 0 - выкл)
  digitalWrite(G,g);  // Установить состояние зеленого светодиода (1 - вкл, 0 - выкл)
}

// Таблица состояний светофора
struct StateConfig {
  int r, y, g;            // состояние светодиодов (0/1 для каждого цвета)
  unsigned long duration; // длительность состояния в миллисекундах
  St nextState;           // следующее состояние по таймеру
  void (*action)(void);   // указатель на функцию - действие при переходе
  void (*update)(void);   // указатель на функцию - действие при обновлении (для особых состояний)
};

// Действия для особых состояний
void redBlinkAction() {
  blinkCnt = 6;  // Установить счетчик миганий для красного мигающего режима
}

void warningUpdate() {
  digitalWrite(Y, !digitalRead(Y));  // Переключить состояние желтого светодиода (мигание)
  t0 = millis();  // Сбросить таймер для следующего переключения
}

void nightUpdate() {
  digitalWrite(Y, !digitalRead(Y));  // Переключить состояние желтого светодиода (мигание)
  t0 = millis();  // Сбросить таймер для следующего переключения
}

void redBlinkUpdate() {
  digitalWrite(R, !digitalRead(R));  // Переключить состояние красного светодиода (мигание)
  blinkCnt--;  // Уменьшить счетчик оставшихся миганий
  t0 = millis();  // Сбросить таймер для следующего переключения
}

void noAction() {}  // Пустая функция - нет дополнительных действий
void noUpdate() {}  // Пустая функция - нет дополнительных обновлений

// Таблица конфигурации состояний
const StateConfig stateTable[] = {
  // r, y, g, duration, nextState, action, update
  {0, 0, 1, 10000, YELLOW, noAction, noUpdate},      // Зеленый - зеленый горит 10 сек, затем желтый
  {0, 1, 0, 3000, RED, noAction, noUpdate},          // Желтый - желтый горит 3 сек, затем красный
  {1, 0, 0, 10000, GREEN, noAction, noUpdate},       // Красный - красный горит 10 сек, затем зеленый
  {0, 0, 0, 500, GREEN, redBlinkAction, redBlinkUpdate}, // Красный мигающий - мигает красный 6 раз, затем зеленый
  {0, 0, 0, 500, WARNING, noAction, warningUpdate},  // Аварийный режим - мигает желтый
  {0, 0, 0, 1000, NIGHT, noAction, nightUpdate}      // Ночной режим - мигает желтый
};

// Проверка особых состояний
bool isSpecialState(St s) {
  // Возвращает true если состояние требует специальной обработки (мигающие режимы)
  return (s == RED_BLINK || s == WARNING || s == NIGHT);
}

// Переход в новое состояние
void next(St s, unsigned long customDur = 0){
  st = s;  // Установить новое текущее состояние
  t0 = millis();  // Запомнить время начала состояния
  dur = (customDur > 0) ? customDur : stateTable[s].duration;  // Установить длительность состояния
  leds(0, 0, 0); // гасим все светодиоды перед установкой нового состояния
  
  // Включаем светодиоды согласно таблице (кроме особых состояний)
  if(!isSpecialState(s)) {
    leds(stateTable[s].r, stateTable[s].y, stateTable[s].g);  // Установить статические светодиоды
  }
  
  // Выполняем действие при переходе
  stateTable[s].action();  // Вызвать специальное действие если оно определено
}

// Обработка таймера состояния
void handleStateTimer() {
  // Обработка завершения мигающего красного режима
  if(st == RED_BLINK && blinkCnt <= 0) {
    next(GREEN);  // Перейти в состояние зеленого после завершения миганий
    return;
  }
  
  // Обработка перехода для особых и обычных состояний
  if(isSpecialState(st)) {
    stateTable[st].update();  // Вызвать функцию обновления для мигающих состояний
  } else {
    next(stateTable[st].nextState);  // Перейти в следующее состояние по таблице
  }
}

// Инициализация
void setup(){
  pinMode(R,1);      // Настроить пин красного светодиода как выход
  pinMode(Y,1);      // Настроить пин желтого светодиода как выход
  pinMode(G,1);      // Настроить пин зеленого светодиода как выход
  pinMode(BTN,2);    // Настроить пин кнопки как вход с подтяжкой (пешеход/ночной режим)
  pinMode(EMERG,2);  // Настроить пин аварийной кнопки как вход с подтяжкой
  next(GREEN);       // Начать работу с зеленого состояния
}

// Основной цикл
void loop(){
  // Обработка кнопки с антидребезгом
  bool p = !digitalRead(BTN);  // Считать состояние кнопки (инвертировано из-за подтяжки)
  if(p && !btn && millis()-lastBtn > 50){  // Если кнопка нажата и была отпущена, и прошел антидребезг
    btn = 1;          // Установить флаг нажатия кнопки
    lastBtn = millis();  // Запомнить время нажатия
  }
  if(!p && btn){      // Если кнопка отпущена и была нажата
    btn = 0;          // Сбросить флаг нажатия
    unsigned long held = millis() - lastBtn;  // Вычислить длительность нажатия
    if(held > 2000) night = !night;  // Долгое нажатие (>2 сек) - переключить ночной режим
    else if(held > 50) ped = 1;      // Короткое нажатие (>50 мс) - запросить переход пешехода
  }
  
  // Аварийный режим
  bool emerg = !digitalRead(EMERG);  // Считать состояние аварийной кнопки
  if(emerg){
    if(st != WARNING) next(WARNING, 500);  // Если не в аварийном режиме - перейти в него
    if(millis() - t0 > dur) {  // Если прошло время до следующего переключения
      stateTable[WARNING].update();  // Вызвать обновление для мигания желтого
    }
    return;  // В аварийном режиме остальная логика не выполняется
  }
  
  if(!emerg && prevEmerg) next(GREEN);  // При выходе из аварийного режима вернуться к зеленому
  prevEmerg = emerg;  // Сохранить предыдущее состояние аварийной кнопки
  
  // Ночной режим
  if(night){
    if(st != NIGHT) next(NIGHT, 1000);  // Если не в ночном режиме - перейти в него
    if(millis() - t0 > dur) {  // Если прошло время до следующего переключения
      stateTable[NIGHT].update();  // Вызвать обновление для мигания желтого
    }
    return;  // В ночном режиме остальная логика не выполняется
  }
  
  // Обработка пешехода
  if(ped && st == GREEN){  // Если запрошен переход и сейчас зеленый
    next(RED_BLINK, 500);  // Перейти в режим мигающего красного
    ped = 0;  // Сбросить флаг запроса перехода
  }
  
  // Основной цикл светофора
  if(millis() - t0 > dur){  // Если время текущего состояния истекло
    handleStateTimer();  // Обработать переход в следующее состояние
  }
}